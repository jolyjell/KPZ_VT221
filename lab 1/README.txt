# Принципи програмування, які були використані у цьому проєкті:

## 1. DRY (Don't Repeat Yourself)

Принцип DRY спрямований на зменшення повторення коду. Це видно в тому, як клас `Money` робить конвертацію між банкнотами і монетами.
- **Відповідний код**: 
  - [Money.cs](./Money.cs) - Рядки [3-11](./Money.cs#L3-L11)

## 2. KISS (Keep It Simple, Stupid)

Принцип KISS полягає у тому, що системи повинні бути максимально простими. Це видно у класі `Product`, який інкапсулює деталі продукту зрозумілим чином.
- **Відповідний код**: [Product.cs](./Product.cs) - Рядки [3-9](./Product.cs#L3-L9)

## 3. Принципи SOLID

### a. SRP (Single Responsibility Principle)

Кожен клас повинен виконувати лише одну задачу. Клас `Money` обробляє валюту, клас `Product` обробляє деталі продукту, а клас `Warehouse` обробляє інвентар.
- **Відповідний код**:
  - [Money.cs](./Money.cs)
  - [Product.cs](./Product.cs)
  - [Warehouse.cs](./Warehouse.cs)

### b. OCP (Open/Closed Principle)

Класи повинні бути відкритими для розширення, але закритими для модифікації. Клас `Money` може бути розширений новими функціями без зміни існуючого коду.
- **Відповідний код**: [Money.cs](./Money.cs)

### c. LSP (Liskov Substitution Principle)

Похідні класи повинні бути підстановлюваними замість базових класів. Цей принцип не демонструється безпосередньо у цьому прикладі, бо нема прикладу наслідування, але структура відповідає цьому принципу.

### d. ISP (Interface Segregation Principle)

Жоден код не повинен залежати від методів, які він не використовує. Класи `Product` і `Warehouse` не мають зайвих методів, які не відносяться до їх функціональності.
- **Відповідний код**:
  - [Product.cs](./Product.cs)
  - [Warehouse.cs](./Warehouse.cs)

### e. DIP (Dependency Inversion Principle)

Cуть полягає у розриві зв'язності між програмними модулями вищого та нижчого рівнів за допомогою спільних абстракцій. Клас `Reporting` залежить від інтерфейсу `Warehouse`, що дозволяє легше вносити зміни та розширення.
- **Відповідний код**: 
  - [Reporting.cs](./Reporting.cs) - Рядки [3-5](./Reporting.cs#L3-L5)

## 4. YAGNI (You Aren't Gonna Need It)

Цей принцип стверджує, що функціонал не повинен додаватися до того, як він стане необхідним. Я застосував цей принцип під час написання коду.
- **Відповідний код**:
  - [Money.cs](./Money.cs)
  - [Product.cs](./Product.cs)
  - [Warehouse.cs](./Warehouse.cs)
  - [Reporting.cs](./Reporting.cs)

## 5. COI (Composition Over Inheritance)

Цей принцип пропонує використовувати складання замість успадкування для досягнення поліморфізму. Клас `Product` використовує клас `Money` через складання, а не через успадкування.
- **Відповідний код**: 
  - [Product.cs](./Product.cs) - Рядки [6-8](./Product.cs#L6-L8)

## 6. Program to Interfaces not Implementations

Цей принцип продемонстровано через клас `Warehouse`, який може бути легко абстрагований до інтерфейсу, що дозволяє іншим класам взаємодіяти з ним, не знаючи його реалізації.
- **Відповідний код**: 
  - [Warehouse.cs](./Warehouse.cs)

## 7. Fail Fast

Клас `Money` кидає винятки одразу при спробі виконання недійсних операцій, наприклад, при встановленні від'ємного значення для монет.
- **Відповідний код**: 
  - [Money.cs](./Money.cs) - Рядки [17-20](./Money.cs#L17-L20)
